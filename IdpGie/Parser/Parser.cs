// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2010
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.5.0
// Machine:  sheldon
// DateTime: 3/5/2014 7:53:56 PM
// UserName: kommusoft
// Input file <parse.yy - 3/5/2014 7:51:33 PM>

// options: no-lines gplex

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using QUT.Gppg;
using System.Linq;
using IdpGie.Core;
using IdpGie.Logic;
using IdpGie.Utils;

namespace IdpGie.Parser
{
public enum Token {
    error=1,EOF=2,IDENTIFIER=3,STRING=4,OBR=5,CBR=6,
    DOT=7,OFB=8,CFB=9,OPA=10,COMMA=11,FLT=12,
    INT=13,IMPLY=14,ARRAY=15};

public struct StateStructure
{
    public String                       str;
    public IFunctionInstance            ter;
    public HeadTail<IFunctionInstance>  vter;
    public IAtom                        atm;
    public HeadTail<IAtom>              vatm;
    public ITheoryItem                  thi;
    public HeadTail<ITheoryItem>        vthi;
}
// Abstract base class for GPLEX scanners
public abstract class ScanBase : AbstractScanner<StateStructure,LexSpan> {
  private LexSpan __yylloc = new LexSpan();
  public override LexSpan yylloc { get { return __yylloc; } set { __yylloc = value; } }
  protected virtual bool yywrap() { return true; }
}

// Utility class for encapsulating token information
public class ScanObj {
  public int token;
  public StateStructure yylval;
  public LexSpan yylloc;
  public ScanObj( int t, StateStructure val, LexSpan loc ) {
    this.token = t; this.yylval = val; this.yylloc = loc;
  }
}

public class IdpParser: ShiftReduceParser<StateStructure, LexSpan>
{
#pragma warning disable 649
  private static Dictionary<int, string> aliasses;
#pragma warning restore 649
  private static Rule[] rules = new Rule[28];
  private static State[] states = new State[43];
  private static string[] nonTerms = new string[] {
      "idpdraw", "identifier", "term", "list", "terms", "atom", "predatom", "body", 
      "element", "clause", "items", "$accept", };

  static IdpParser() {
    states[0] = new State(new int[]{7,4,3,31,1,40,2,-3},new int[]{-1,1,-11,3,-9,5,-10,8,-6,9,-7,15,-2,16});
    states[1] = new State(new int[]{2,2});
    states[2] = new State(-1);
    states[3] = new State(-2);
    states[4] = new State(-4);
    states[5] = new State(new int[]{7,6});
    states[6] = new State(new int[]{7,4,3,31,1,40,2,-3},new int[]{-11,7,-9,5,-10,8,-6,9,-7,15,-2,16});
    states[7] = new State(-5);
    states[8] = new State(-7);
    states[9] = new State(new int[]{14,10,7,-8});
    states[10] = new State(new int[]{3,31,1,39},new int[]{-8,11,-6,12,-7,15,-2,16});
    states[11] = new State(-9);
    states[12] = new State(new int[]{11,13,7,-10});
    states[13] = new State(new int[]{3,31,1,39},new int[]{-8,14,-6,12,-7,15,-2,16});
    states[14] = new State(-11);
    states[15] = new State(-12);
    states[16] = new State(new int[]{5,17,14,-15,7,-15,11,-15});
    states[17] = new State(new int[]{15,23,3,31,8,33,13,36,12,37,4,38,6,-16},new int[]{-5,18,-3,20,-2,27,-4,32});
    states[18] = new State(new int[]{6,19});
    states[19] = new State(-14);
    states[20] = new State(new int[]{11,21,6,-17,9,-17});
    states[21] = new State(new int[]{15,23,3,31,8,33,13,36,12,37,4,38,6,-16,9,-16},new int[]{-5,22,-3,20,-2,27,-4,32});
    states[22] = new State(-18);
    states[23] = new State(new int[]{5,24});
    states[24] = new State(new int[]{15,23,3,31,8,33,13,36,12,37,4,38,6,-16},new int[]{-5,25,-3,20,-2,27,-4,32});
    states[25] = new State(new int[]{6,26});
    states[26] = new State(-19);
    states[27] = new State(new int[]{5,28,11,-21,6,-21,9,-21});
    states[28] = new State(new int[]{15,23,3,31,8,33,13,36,12,37,4,38,6,-16},new int[]{-5,29,-3,20,-2,27,-4,32});
    states[29] = new State(new int[]{6,30});
    states[30] = new State(-20);
    states[31] = new State(-27);
    states[32] = new State(-22);
    states[33] = new State(new int[]{15,23,3,31,8,33,13,36,12,37,4,38,9,-16},new int[]{-5,34,-3,20,-2,27,-4,32});
    states[34] = new State(new int[]{9,35});
    states[35] = new State(-26);
    states[36] = new State(-23);
    states[37] = new State(-24);
    states[38] = new State(-25);
    states[39] = new State(-13);
    states[40] = new State(new int[]{7,41,14,-13});
    states[41] = new State(new int[]{7,4,3,31,1,40,2,-3},new int[]{-11,42,-9,5,-10,8,-6,9,-7,15,-2,16});
    states[42] = new State(-6);

    for (int sNo = 0; sNo < states.Length; sNo++) states[sNo].number = sNo;

    rules[1] = new Rule(-12, new int[]{-1,2});
    rules[2] = new Rule(-1, new int[]{-11});
    rules[3] = new Rule(-11, new int[]{});
    rules[4] = new Rule(-11, new int[]{7});
    rules[5] = new Rule(-11, new int[]{-9,7,-11});
    rules[6] = new Rule(-11, new int[]{1,7,-11});
    rules[7] = new Rule(-9, new int[]{-10});
    rules[8] = new Rule(-9, new int[]{-6});
    rules[9] = new Rule(-10, new int[]{-6,14,-8});
    rules[10] = new Rule(-8, new int[]{-6});
    rules[11] = new Rule(-8, new int[]{-6,11,-8});
    rules[12] = new Rule(-6, new int[]{-7});
    rules[13] = new Rule(-6, new int[]{1});
    rules[14] = new Rule(-7, new int[]{-2,5,-5,6});
    rules[15] = new Rule(-7, new int[]{-2});
    rules[16] = new Rule(-5, new int[]{});
    rules[17] = new Rule(-5, new int[]{-3});
    rules[18] = new Rule(-5, new int[]{-3,11,-5});
    rules[19] = new Rule(-3, new int[]{15,5,-5,6});
    rules[20] = new Rule(-3, new int[]{-2,5,-5,6});
    rules[21] = new Rule(-3, new int[]{-2});
    rules[22] = new Rule(-3, new int[]{-4});
    rules[23] = new Rule(-3, new int[]{13});
    rules[24] = new Rule(-3, new int[]{12});
    rules[25] = new Rule(-3, new int[]{4});
    rules[26] = new Rule(-4, new int[]{8,-5,9});
    rules[27] = new Rule(-2, new int[]{3});
  }

  protected override void Initialize() {
    this.InitSpecialTokens((int)Token.error, (int)Token.EOF);
    this.InitStates(states);
    this.InitRules(rules);
    this.InitNonTerminals(nonTerms);
  }

  protected override void DoAction(int action)
  {
#pragma warning disable 162, 1522
    switch (action)
    {
      case 2: // idpdraw -> items
{this.result.Reinitialize(ValueStack[ValueStack.Depth-1].vthi);}
        break;
      case 3: // items -> /* empty */
{CurrentSemanticValue.vthi = null;}
        break;
      case 4: // items -> DOT
{CurrentSemanticValue.vthi = null;}
        break;
      case 5: // items -> element, DOT, items
{CurrentSemanticValue.vthi = new HeadTail<ITheoryItem>(ValueStack[ValueStack.Depth-3].thi,ValueStack[ValueStack.Depth-1].vthi);}
        break;
      case 6: // items -> error, DOT, items
{CurrentSemanticValue.vthi = ValueStack[ValueStack.Depth-1].vthi;}
        break;
      case 7: // element -> clause
{CurrentSemanticValue.thi = ValueStack[ValueStack.Depth-1].thi;}
        break;
      case 8: // element -> atom
{CurrentSemanticValue.thi = ValueStack[ValueStack.Depth-1].atm;}
        break;
      case 9: // clause -> atom, IMPLY, body
{CurrentSemanticValue.thi = new PositiveClause(ValueStack[ValueStack.Depth-3].atm,ValueStack[ValueStack.Depth-1].vatm);}
        break;
      case 10: // body -> atom
{CurrentSemanticValue.vatm = new HeadTail<IAtom>(ValueStack[ValueStack.Depth-1].atm,null);}
        break;
      case 11: // body -> atom, COMMA, body
{CurrentSemanticValue.vatm = new HeadTail<IAtom>(ValueStack[ValueStack.Depth-3].atm,ValueStack[ValueStack.Depth-1].vatm);}
        break;
      case 12: // atom -> predatom
{CurrentSemanticValue.atm = ValueStack[ValueStack.Depth-1].atm;}
        break;
      case 13: // atom -> error
{CurrentSemanticValue.atm = null;}
        break;
      case 14: // predatom -> identifier, OBR, terms, CBR
{CurrentSemanticValue.atm = this.Context.GetAtom(ValueStack[ValueStack.Depth-4].str,ValueStack[ValueStack.Depth-2].vter);}
        break;
      case 15: // predatom -> identifier
{CurrentSemanticValue.atm = this.Context.GetAtom(ValueStack[ValueStack.Depth-1].str);}
        break;
      case 16: // terms -> /* empty */
{ CurrentSemanticValue.vter = null;}
        break;
      case 17: // terms -> term
{ CurrentSemanticValue.vter = new HeadTail<IFunctionInstance>(ValueStack[ValueStack.Depth-1].ter);}
        break;
      case 18: // terms -> term, COMMA, terms
{ CurrentSemanticValue.vter = new HeadTail<IFunctionInstance>(ValueStack[ValueStack.Depth-3].ter,ValueStack[ValueStack.Depth-1].vter);}
        break;
      case 19: // term -> ARRAY, OBR, terms, CBR
{ CurrentSemanticValue.ter = ArrayFunction.ToInstance(ValueStack[ValueStack.Depth-2].vter); }
        break;
      case 20: // term -> identifier, OBR, terms, CBR
{ CurrentSemanticValue.ter = this.Context.GetFunctionInstance(ValueStack[ValueStack.Depth-4].str.Trim(),ValueStack[ValueStack.Depth-2].vter);}
        break;
      case 21: // term -> identifier
{ CurrentSemanticValue.ter = this.Context.GetFunctionInstance(ValueStack[ValueStack.Depth-1].str.Trim());}
        break;
      case 22: // term -> list
{ CurrentSemanticValue.ter = ValueStack[ValueStack.Depth-1].ter;}
        break;
      case 23: // term -> INT
{ CurrentSemanticValue.ter = new FunctionIntegerInstance(LocationStack[LocationStack.Depth-1].ToString());}
        break;
      case 24: // term -> FLT
{ CurrentSemanticValue.ter = new FunctionFloatInstance(LocationStack[LocationStack.Depth-1].ToString());}
        break;
      case 25: // term -> STRING
{ CurrentSemanticValue.ter = new FunctionStringInstance(LocationStack[LocationStack.Depth-1].LiteralString());}
        break;
      case 26: // list -> OFB, terms, CFB
{ CurrentSemanticValue.ter = ArrayFunction.ToInstance(ValueStack[ValueStack.Depth-2].vter);}
        break;
      case 27: // identifier -> IDENTIFIER
{ CurrentSemanticValue.str = LocationStack[LocationStack.Depth-1].ToString();}
        break;
    }
#pragma warning restore 162, 1522
  }

  protected override string TerminalToString(int terminal)
  {
    if (aliasses != null && aliasses.ContainsKey(terminal))
        return aliasses[terminal];
    else if (((Token)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
        return ((Token)terminal).ToString();
    else
        return CharToString((char)terminal);
  }

private LocalInputContext context;
private DrawTheory result;

public LocalInputContext Context {
    get {
        return this.context;
    }
    set {
        this.context = value;
    }
}

public DrawTheory Result {
    get {
        return this.result;
    }
}
  
public IdpParser (ScanBase sb, DrawTheory dt) : base(sb) {
    this.context = new LocalInputContext();
    this.result = dt;
}
}
}
