//
//  WeakFlyweight.cs
//
//  Author:
//       Willem Van Onsem <Willem.VanOnsem@cs.kuleuven.be>
//
//  Copyright (c) 2014 Willem Van Onsem
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;

namespace IdpGie.Abstract {

	/// <summary>
	/// The implementation of a weak flyweight.
	/// </summary>
	/// <remarks>
	/// <para>A flyweight pattern is used to reduce the memory footprint and sometimes the computation overhead (for instance to compare two objects).
	/// A drawback of the method is that the flyweight requires additional memory and the computational overhead when creating an object.</para>
	/// <para>The <see cref="WeakFlyweight"/> objects are sensible to the garbage collector of the runtime environment.</para>
	/// </remarks>
	/// <typeparam name="TKey">
	/// The type of parameter from which objects are created.
	/// </typeparam>
	/// <typeparam name="TValue">
	/// The type of objects generated by the flyweight.
	/// </typeparam>
	public class WeakFlyweight<TKey,TValue> : IFlyweight<TKey,TValue> {

		private readonly Dictionary<TKey,WeakReference> cache = new Dictionary<TKey, WeakReference> ();
		private readonly Func<TKey,TValue> generator;

        #region IFlyWeight implementation
		/// <summary>
		///  Gets the generator of the flyweight. 
		/// </summary>
		/// <value>
		///  The generator of the flyweight. A function that generates a new object in case the flyweight does not contain an
		/// object associated with the given key. 
		/// </value>
		public Func<TKey, TValue> Generator {
			get {
				return this.generator;
			}
		}

		/// <summary>
		///  Gets a value indicating whether this flyweight is weak. 
		/// </summary>
		/// <value>
		/// <c>true</c> if this instance is weak; otherwise, <c>false</c>.
		/// </value>
		/// <remarks>
		/// <para>The value of this parameter is always <c>true</c>.</para>
		/// </remarks>
		public bool IsWeak {
			get {
				return true;
			}
		}

		/// <summary>
		/// Gets a value indicating whether this <see cref="IdpGie.Abstract.WeakFlyweight`2"/> supports <see cref="IDispose"/>.
		/// </summary>
		/// <value>
		/// <c>true</c> if this flyweight supports <see cref="IDispose"/>; otherwise, <c>false</c>.
		/// </value>
		/// <remarks>
		/// <para>This implementation of the <see cref="IFlyweight`2"/> pattern does not support <see cref="IDispose"/>, the value is always <c>false</c>.</para>
		/// </remarks>
		public bool DisposeSupport {
			get {
				return false;
			}
		}
        #endregion

		/// <summary>
		/// Initializes a new instance of the <see cref="IdpGie.Abstract.WeakFlyweight`2"/> class with a given generator.
		/// </summary>
		/// <param name='generator'>
		/// The generator that generates a new instance in case no object for the given parameters has been generated yet.
		/// </param>
		public WeakFlyweight (Func<TKey,TValue> generator) {
			this.generator = generator;
		}

        #region IFlyWeight implementation
		/// <summary>
		/// Gets a pointer to an earlier generated object associated with the given <paramref name="key"/>, otherwise uses the <see cref="IFlyweight`2.Generator"/> to generate
		/// a new object.
		/// </summary>
		/// <returns>
		/// A references to an earlier generated object, or the newly generated object.
		/// </returns>
		/// <param name='key'>
		/// The key on which an object is generated or associated.
		/// </param>
		public TValue GetOrCreate (TKey key) {
			WeakReference wr;
			TValue res;
			if (!this.cache.TryGetValue (key, out wr)) {
				res = generator (key);
				this.cache.Add (key, new WeakReference (res));
			} else if (!wr.IsAlive) {
				res = generator (key);
				wr.Target = res;
			} else {
				res = (TValue)wr.Target;
			}
			return res;
		}

		/// <summary>
		/// Checks if the flyweight contains an object associated with the given <paramref name="key"/>.
		/// </summary>
		/// <param name='key'>
		/// The given parameter.
		/// </param>
		/// <returns>
		/// <c>true</c> if the <see cref="IFlyweight`2"/> already contains an object associated with the given <paramref name="key"/>, <c>false</c> otherwise.
		/// </returns>
		/// <remarks>
		/// <para>In case of a weak flyweight, once an object is collected with the given <paramref name="key"/>, this method will return <c>false</c> until
		/// it is generated again.</para>
		/// </remarks>
		public bool Contains (TKey key) {
			WeakReference wr;
			return (this.cache.TryGetValue (key, out wr) && wr.IsAlive);
		}
        #endregion

		/// <summary>
		/// Compact this instance by removing all information from the instance corresponding to objects already collected.
		/// </summary>
		public void Compact () {
			Stack<TKey> toRemove = new Stack<TKey> ();
			foreach (KeyValuePair<TKey,WeakReference> kvp in this.cache) {
				if (!kvp.Value.IsAlive) {
					toRemove.Push (kvp.Key);
				}
			}
			foreach (TKey key in toRemove) {
				this.cache.Remove (key);
			}
		}

	}

}